%----------------------------------------------------------------------------
\section{FreeRTOS}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\subsection{Bevezetés}
%----------------------------------------------------------------------------

A FreeRTOS a Real Time Engineers Ltd. által fejlesztett valós idejû operációs rendszer. A fejlesztõk céljai között volt a rendszer erõforrásigényének minimalizálása, hogy a legkisebb beágyazott rendszereken is futtatható legyen. Ebbõl adódóan csak az alap funkciók vannak megvalósítva, mint ütemezés, taszkok közötti kommunikáció lehetõsége, memóriamenedzsment, de nincs beépített támogatás hálózati kommunikációra vagy bármiféle külsõ hardver használatára (ezeket vagy nekünk meg megírnunk, vagy harmadik féltõl származó kódot kell használnunk).

A rendszer módosított GPLv2 licencet használ. A licencmódosítás lehetõvé teszi GPL-tõl eltérõ licenccel ellátott modulok használatát, amennyiben azok a FreeRTOS-sal kizárólag a FreeRTOS API-n keresztül kommunikálnak.

%----------------------------------------------------------------------------
\subsection{Taszkok}
%----------------------------------------------------------------------------

A FreeRTOS nem korlátozza a létrehozható taszkok és prioritások számát, amíg a rendelkezésre álló memória lehetõvé teszi azok futtatását. A rendszer lehetõséget biztosít ciklikus és nem ciklikus taszkok futtatására egyaránt.

A beágyazott rendszerek döntõ része egymagos processzorokat használ, amibõl az következik, hogy egyszerre csak egy taszk futhat. A taszkok eszerint két nagy csoportba oszthatóak: éppen futó taszk (\textbf{Fut} állapot), illetve az összes többi (\textbf{Nem fut} állapot).

\begin{figure}[h!]
\center
\resizebox{8cm}{!}{
\includegraphics{figures/FreeRTOS/01_FreeRTOS_states.png}}
\caption{Taszk lehetséges állapotai a FreeRTOS rendszerben (egyszerûsített).}
\label{fig:01_FreeRTOS_states}
\end{figure}

Annak, hogy egy taszk éppen miért nem fut, több oka lehet. Ez alapján a \textbf{Nem fut} állapot több állapotra felosztható.
Ha egy taszk képes lenne futni, de például egy nagyobb prioritású taszk birtokolja a processzort, akkor a taszk állapota \textbf{Futásra kész}. Ha a taszk valamilyen eseményre vár (idõzítés, másik taszk szinkronizáló jele), akkor a taszk \textbf{Blokkolt} állapotban van. Az operációs rendszer lehetõséget ad arra, hogy a taszkokat függvényhívással \textbf{Felfüggesztett} állapotba kényszerítsük. Ekkor egy másik függvényhívással tudjuk visszahozni az ütemezendõ feladatok sorába a taszkot.

A taszkok önként lemondhatnak a futásról (idõzítés, szinkronizáció, taskYIELD() függvény hívása), viszont futó állapotba csak az ütemezõ helyezheti.

\begin{figure}[h!]
\center
\resizebox{13cm}{!}{
\includegraphics{figures/FreeRTOS/02_FreeRTOS_states_expanded.png}}
\caption{Taszk lehetséges állapotai a FreeRTOS rendszerben.}
\label{fig:02_FreeRTOS_states_expanded}
\end{figure}

%----------------------------------------------------------------------------
\subsubsection{Idle taszk}
%----------------------------------------------------------------------------

A processzor folyamatosan utasításokat hajt végre mûködése közben (eltekintve a különbözõ energiatakarékos üzemmódoktól), ezért legalább egy taszknak mindig Futásra kész állapotban kell lennie. Hogy ez biztosítva legyen, az ütemezõ indulásakor automatikusan létrejön egy ciklikus \textbf{Idle taszk}.

Az Idle taszk a legkisebb prioritással rendelkezik, így biztosítva, hogy elhagyja a Fut állapotot, amint egy magasabb prioritású taszk Futásra kész állapotba kerül.

Taszk törlése esetén az Idle taszk végzi el a különbözõ erõforrások felszabadítását. Mivel a FreeRTOS nem biztosít védelmet egy taszk \emph{kiéheztetésével} szemben ezért fontos, hogy az alkalmazás tervezésekor biztosítsunk olyan idõszeletet, amikor másik, nagyobb prioritású taszk nem fut.

%----------------------------------------------------------------------------
\paragraph{Idle hook függvény}
%----------------------------------------------------------------------------

Elõfordulhat, hogy az alkalmazásunkban olyan funkciót szeretnénk megvalósítani, amelyet az Idle taszk minden egyes iterációjára le kell futtatni (például teljesítménymérés érdekében). Ezt a célt szolgálja az \textbf{Idle hook} függvény, ami az Idle taszk minden lefutásakor meghívódik.

Az Idle hook általános felhasználása:
\begin{itemize}
\item Alacsony prioritású háttérfolyamat, vagy folyamatos feldolgozás,
\item A szabad processzoridõ mérése (teljesítménymérés),
\item Processzor alacsony fogyasztású üzemmódba váltása.
\end{itemize}

%----------------------------------------------------------------------------
\subparagraph{Korlátozások az Idle hook függvénnyel kapcsolatban}
%----------------------------------------------------------------------------

\begin{enumerate}
\item Az Idle hook függvény nem hívhat blokkoló vagy felfüggesztést indító függvényeket[lábjegyzet->A hook függvény blokkolása esetén felléphet az az eset, hogy nincs Futásra kész állapotban levõ taszk],
\item Ha az alkalmazás valahol töröl egy taszkot, akkor az Idle hook függvénynek elfogadható idõn belül vissza kell térnie. [lábjegyzet->Az Idle taszk felelõs a kernel erõforrások felszabadításáért, ha egy taszk törlésre kerül. Ha az Idle taszk bentragad az Idle hook-ban, akkor ez a tisztítás nem tud bekövetkezni.]
\end{enumerate}

%----------------------------------------------------------------------------
\subsection{Ütemezõ}
%----------------------------------------------------------------------------

A FreeRTOS által használt ütemezési mechanizmust Fix Prioritásos Preemptív Ütemezésnek hívjuk[lábjegyzet->A FreeRTOS kooperatív ütemezést is támogat, viszont a valós idejû futás eléréséhez a preemptív ütemezés szükséges, ezért a továbbiakban csak a preemptív ütemezéssel foglalkozunk.]. \emph{Fix prioritásos}, mivel a rendszer magától nem változtatja a prioritásokat, \emph{preemptív}, mert egy taszk Futásra kész állapotba lépésekor preemtálja az éppen futó taszkot, ha a futó taszk prioritása alacsonyabb.

[ToDo -> Itt átfogalmazni kicsit a dolgokat. Elég kusza a gondolatmenet.]

A taszkok lehetnek Blokkolt állapotban, ahonnan egy esemény bekövetkezését követõen automatikusan Futásra kész állapotba kerülnek.

Idõbeli események azok, amik egy bizonyos idõpillanatban következnek be (például egy késleltetési idõ letelik). Az idõbeli eseményeket kihasználva lehetõség nyílik periodikus futtatásra, vagy idõtúllépés detektálására.

Szinkronizáló események azok, amikor egy taszk vagy megszakításkezelõ rutin jelzést küld valamilyen kommunikációs struktúrán keresztül egy másik taszknak. Tipikusan aszinkron jelzésre használjuk, mint például adat érkezését egy periférián keresztül.

%----------------------------------------------------------------------------
\subsubsection{Taszkok prioritásának meghatározása}
%----------------------------------------------------------------------------

[ToDo -> Itt átfogalmazni kicsit a dolgokat. Elég kusza a gondolatmenet.]

Ökölszabályként alkalmazható, hogy a hard real-time funkciókat magasabb prioritással látjuk el, mint a soft real-time funkciókat.

Rate Monotonic Scheduling (Gyakoriság Monoton Ütemezés) az a gyakran alkalmazott prioritás-hozzárendelés, amikor minden taszkhoz egyedi prioritásszintet rendelünk a végrehajtási gyakoriság függvényében. A gyakrabban lefutó folyamatokhoz magasabb, a ritkábban lefutó folyamatokhoz alacsonyabb prioritást állítunk be.

%----------------------------------------------------------------------------
\subsection{Kommunikációs objektumok}
%----------------------------------------------------------------------------

[ToDo -> Átfogalmazni. Ne legyen nagyon redundáns az átlalános résszel.]

Az alkalmazások egymástól független taszkok konstrukciójából áll. Viszont ezeknek a taszkoknak ahhoz, hogy a feladatukat el tudják látni, gyakran kommunikálniuk kell egymással.
A FreeRTOS három alap kommunikációs struktúrát kínál a felhasználónak:
\begin{itemize}
\item sor (\emph{queue}),
\item szemafor (\emph{semaphore}),
	\begin{itemize}
    \item bináris (\emph{binary semaphore}),
    \item számláló (\emph{counting semaphore}),
	\end{itemize}
\item mutex (\emph{mutex} [\textbf{MUT}ual \textbf{EX}cluison]).
\end{itemize}

%----------------------------------------------------------------------------
\subsubsection{Sorok (queues)}
%----------------------------------------------------------------------------

A sorok fix méretû adatból tudnak véges számú üzenetet tárolni. Ezek a jellemzõk a sor létrehozásakor kerülnek meghatározásra. Alapértelmezetten FIFO-ként mûködnek (First In First Out), bár a FreeRTOS lehetõvé teszi a sor elejére való írást is.
A sorba való írás során másolat készül az eredeti változóról, és ez a másolat kerül tárolásra a sorban. Olvasáskor a paraméterként átadott memóriacímre kerül átmásolásra, ezért figyelni kell arra, hogy az átadott változó által elfoglalt memória legalább akkora legyen, mint a sor által tartalmazott adattípus mérete. Amennyiben a továbbítandó adattípus már nagynak tekinthetõ, akkor érdemes a memóriára mutató pointereket elhelyezni a sorban, ezzel csökkentve a RAM kihasználtságát (ekkor viszont különösen figyelni kell arra, hogy a kijelölt memóriaterület tolajdonosa egyértelmû legyen, vagyis ne történjen különbözõ taszkokból módosítás egyidõben, illetve biztosítani kell a memóriaterüet érvényességét). A FreeRTOS API kétféle függvényt használ olvasásra:
\begin{itemize}
\item Az egyik automatikusan eltávolítja a kiolvasott elemet a sorból (\textbf{xQueueReceive()}),
\item A másik kiolvassa a soronkövetkezõ elemet, de azt nem távolítja el a sorból(\textbf{xQueuePeek()}).
\end{itemize}

A FreeRTOS-ban minden kommunikációs struktúra a sor valamilyen speciális megvalósítása.

A sorok egy taszkhoz sem tartoznak, így egy sorba akár több taszk is írhat, illetve olvashat egy alkalmazáson belül.

%----------------------------------------------------------------------------
\paragraph{Olvasás sorból}
%----------------------------------------------------------------------------

Sorból való olvasás során az olvasó függvény paramétereként megadhatunk egy várakozási idõtartamot. A taszk maximálisan ennyi ideig várakozik Blokkolt állapotban új adat érkezésére, amennyiben a sor üres. Ha ezen idõtartam alatt nem érkezik adat, akkor a függvény visszatér, és a visszatérési értékével jelzi az olvasás sikertelenségét. A Blokkolt állapotból a taszk Futásra kész állapotba kerül, ha:
\begin{itemize}
\item Adat érkezik a sorba a megadott idõtartamon belül,
\item Nem érkezik adat a sorba, de a megadott várakozási idõ lejárt.
\end{itemize}

Egy sorból egyszerre több taszk is kezdeményezhet olvasást, ezért elõfordulhat az az eset, hogy több taszk is Blokkolt állapotban várja az adat érkezését. Ebben az esetben csak egy taszk kerülhet Futásra kész állapotba az érkezésének hatására. A rendszer a legnagyobb prioritású taszkot választja, vagy ha a várakozó taszkok azonos prioritásúak, akkor a legrégebben várakozót helyezi a Futásra kész állapotba.

%----------------------------------------------------------------------------
\paragraph{Írás sorba}
%----------------------------------------------------------------------------

Az olvasáshoz hasonlóan a sorba való írás során is megadható egy várakozási idõ. Ha a sorban nincs üres hely az adat írásához, akkor a taszk Blokkolt állapotba kerül, amelybõl Futásra kész állapotba lép, ha:
\begin{itemize}
\item Megüresedik egy tároló a sorban,
\item Letelik a maximális várakozási idõ.
\end{itemize}

Egy sorba több taszk is kezdeményezhet írást egyidõben. Ekkor ha több taszk is Blokkolt állapotba kerül, akkor hely felszabadulásakor a legnagyobb prioritású taszkoz választja a rendszer, azonos prioritású taszkok esetén a legrégebben várakozót helyezi Futásra kész állapotba.

%----------------------------------------------------------------------------
\subsubsection{Szemaforok}
%----------------------------------------------------------------------------

Két szemafor típust különböztetünk meg:
\begin{itemize}
\item Bináris szemafor, amikor a szemafor két értéket vehet fel,
\item Számláló szemafor, mikor a szemafor több állapotot is felvehet.
\end{itemize}

A szemaforon két mûvelet értelmezett:
\begin{itemize}
\item A szemafor jelzése (elterjedt elnevezések: give, signal, post, V() mûvelet[lábjegyzet-> Dijkstra holland, verhogen]), amikor a szemafor értéke növelésre kerül.
\item A szemafor elvétele (elterjedt elnevezések: take, wait, pend, P() mûvelet [lábjegyzet-> proberen]), amikor a szemafor elõször tesztelésre kerül, hogy tartalmaz-e elemet, ha igen, akkor az értékét csökkentjük, ha nem, akkor várakozunk addig, amíg valamelyik másik taszk elérhetõvé nem teszi azt.
\end{itemize}

A FreeRTOS rendszerben implementált szemaforok paraméterei között megadható a maximális tick szám, ameddig várakozhat a szemaforra az adott taszk. Ezen maximális idõtartam megadása az esetek nagy részében megoldást jelent a holtponti helyzetekre.

A szemafor látszólag egyszerûen helyettesíthetõ egy egyszerû változó (boolean vagy elõjel nélküli egész) használatával, viszont a beépített szemafor struktúra atomi mûveletként kerül kezelésre (így nem következik be ütemezés a szemafor tesztelése és állítása közben), illetve a rendszer automatikusan tudja kezelni a várakozó folyamatok állapotok közti mozgatását.

%----------------------------------------------------------------------------
\paragraph{Bináris szemafor}
%----------------------------------------------------------------------------

Bináris szemafor esetén a szemafor két értéket vehet fel. Felfogható úgy is, mint egy egy adat tárolására (egy elem hosszú) sor, melynek nem vizsgáljuk a tartalmazott értékét, csak azt, hogy éppen tartalmaz-e adatot vagy sem.

Leggyakoribb felhasználása a taszkok szinkronizálása. Ekkor az egyik taszk a futásának egy adott pontján várakozik egy másik taszk jelzésére. Ezzel a módszerrel megvalósítható a megszakítások taszkokban történõ kezelése, ezzel is minimalizálva a megszakítási rutin hosszát.

Bináris szemafor használatakor különös figyelmet kell fordítani arra, hogy ha a szemafor egy adott taszkban gyakrabban kerül jelzésre, mint ahogy feldolgozzuk, akkor jelzések veszhetnek el (amíg az egyik jelzés várakozik, addig az utána következõ eseményeknek nincs lehetõségük várakozó állapotba kerülni).

%----------------------------------------------------------------------------
\paragraph{Számláló szemafor}
%----------------------------------------------------------------------------

A számláló típusú szemafor minden jelzéskor növeli az értékét. Ekkor (amíg el nem éri a maximális értékét) nem kerül Blokkolt állapotba a jelzõ taszk. A számláló szemafor felfogható úgy, mint egy egynél több adat tárolására képes sor, melynek nem vizsgáljuk az értékét, csak azt, hogy éppen tartalmaz-e még adatot vagy sem.

Két felhasználása elterjedt a számláló szemaforoknak:
\begin{itemize}
\item Események számlálása: ekkor minden esemény hatására növeljük a szemafor értékét (új elemet helyezünk a sorba). A szemafor aktuális értéke a beérkezett és a feldolgozott események különbsége. A számlálásra használt szemafor inicializálási értéke nulla.
\item Erõforrás menedzsment: ekkor a szemafor értéke a rendelkezésre álló erõforrások számát mutatja. Mikor az operációs rendszertõl az erõforrást igényeljük, akkor a szemafor értékét csökkentjük, mikor felszabadítjuk a birtolkolt erõforrást, akkor a szemafor értékét növeljük. Ha a szemafor értéke nulla, akkor nincs rendelkezésre álló erõforrás. Erõforrások kezelésére használt számláló szemafor esetén az inicializálási érték az elérhetõ erõforrások száma.
\end{itemize}

%----------------------------------------------------------------------------
\subsubsection{Mutexek}
%----------------------------------------------------------------------------

Taszkok vagy taszkok és megszakítási rutinok között megosztott erõforrás kezelésekor a Mutex (kölcsönös kizárás) használata indokolt. Mikor egy taszk vagy megszakítás hozzáférést indít egy erõforráshoz, akkor a hozzá tartozó mutex-et elkéri. Ha az erõforrás szabad, akkor az igénylõ taszk megkapja a kezelés jogát, és mindaddig megtartja, amíg be nem fejezi az erõforrással való munkát. A mutex-et a lehetõ legkorábban (az erõforrással való munka befejeztével) fel kell szabadítani, ezzel is csökkentve az esetleges holtpont kialakulásának veszélyét.

Látható, hogy a mutex nagyon hasonlít a bináris szemaforhoz. A különbség abból adódik, hogy mivel a bináris szemafort leggyakrabban szinkronizációra használjuk, ezért azt nem kell felszabadítani: a jelzõ taszk vagy megszakítás jelzést ad a szemforon keresztül a feldolgozó taszknak. A feldolgozó taszk elveszi a szemafort, de a feldolgozás befejeztével a szemafort nem adja vissza.

A felhasználásból adódó különbségek miatt a mutex védett a prioritás inverzió problémájával szemben, míg a bináris szemafor implementációjából hiányzik.[lábjegyzet-> a FreeRTOS prioritás öröklési mechanizmusa csak egyszerû implementációt tartalmaz, és feltételezi, hogy csak egy taszk csak egy mutex-et birtokol egy adott pillanatban.]

%----------------------------------------------------------------------------
\subsection{Megszakítás-kezelés}
%----------------------------------------------------------------------------

Beágyazott rendszereknél gyakran kell a környezettõl származó eseményekre reagálni (például adat érkezése valamely kommunikációs interfészen). Az ilyen események kezelésekor a megszakítások alkalmazása gyakran elengedhetetlen.

Megszakítás használata esetén figyelni kell arra, hogy a megszakítási rutinokban csak \emph{FromISR}-re végzõdõ API függvényeket hívhatunk. Ellenkezõ esetben nem várt mûködés következhet be (blokkoljuk a megszakítási rutint, ami az alkalmazás fagyásához vezethet; kontextus-váltást okozunk, amibõl nem térünk vissza, így a megszakítási rutinból sosem lépünk ki, stb.).

A FreeRTOS ütemezõje a (STM32-re épülõ rendszerekben) a SysTick interruptot használja az ütemezõ periodikus futtatásához. A megszakítási rutin futása közben emiatt nem történik ütemezés. Amennyiben valamely magasabb prioritású taszkunk a megszakítás hatására Futásra kész állapotba kerül, akkor vagy a következõ ütemezéskor kapja meg a processzort, vagy explicit függvényhívással kell kérni az operációs rendszer az ütemezõ futtatására.

Az alacsonyabb prioritású megszakítások szintén nem tudnak érvényre jutni, így azok bekövetkezésérõl nem kapunk értesítést (az elsõ beérkezõ, alacsonyabb prioritású megszakítás jelzõ bitje bebillen az esemény hatására, de amennyiben több is érkezik a magasabb prioritású megszakítási rutin futása alatt, úgy azok elvesznek).
Az említett problémák végett a megszakítási rutint a lehetõ legrövidebb idõ alatt be kell fejezni.

%----------------------------------------------------------------------------
\subsubsection{Késleltetett megszakítás-kezelés}
%----------------------------------------------------------------------------

A megszakítási rutint a lehetõ legrövidebb idõ alatt el kell hagyni, emiatt célszerû a kevésbé fontos mûveleteket egy kezelõ taszkban megvalósítani. A FreeRTOS a szemaforokon keresztül biztosít lehetõséget a megszakítás és taszk szinkronizációjára.

A megszakítás hatására a megszakítási rutinban csak szükséges lépéseket végezzük el (például eseményjelzõ bitek törlése), majd egy szemaforon keresztül jelzi a feldolgozó taszknak az esemény bekövetkeztét. Ha a feldolgozás idõkritikus, akkor a feldolgozó szálhoz rendelt magas prioritással biztosítható, hogy az éppen futó taszkot preemtálja. Ekkor a megszakítási rutin végén az ütemezõ meghívásával a visszatérés utána azonnal feldolgozásra kerül az esemény.

Az eseményt kezelõ taszk blokkoló \emph{take} utasítással várakozik Blokkolt állapoban a szemafor érkezésére. A jelzés hatására Futásra kész állapotba kerül, ahonnan az ütemezõ (az éppen futó taszkot preemtálva) Futó állapotba mozgatja. Az esemény feldolgozását követõen újra meghívja a blokkoló \emph{take} utasítást, így újból Blokkolt állapotba kerül az újabb esemény bekövetkezéséig.

Todo: Példa

\begin{figure}[h!]
\center
\resizebox{13cm}{!}{
\includegraphics{figures/FreeRTOS/03_deferred_interrupt.png}}
\caption{Megszakítások késleletett feldolgozásának szemléltetése.}
\label{fig:03_deferred_interrupt}
\end{figure}

%----------------------------------------------------------------------------
\subsubsection{Megszakítások egymásba ágyazása}
%----------------------------------------------------------------------------

Az STM32 mikrokontrollerek lehetõvé teszik prioritások hozzárendelését a megszakításokhoz. Ezáltal létrejöhet olyan állapot, amikor egy magasabb prioritású megszakítás érkezik egy alacsonyabb szintû megszakítási rutin futása közben. Ekkor a magasabb prioritású megszakítás késleltetés nélkül érvényre jut, és a magasabb prioritású megszakítási rutin befejeztével az alacsony prioritású folytatódik.

A FreeRTOS rendszer konfigurációs fájlában (\emph{FreeRTOSConfig.h}) beállítható azon legmagasabb prioritás, amihez a FreeRTOS hozzáférhet. Ezáltal a megszkaításoknak két csoportja adódik:
\begin{itemize}
\item A FreeRTOS által kezelt megszakítások,
\item A FreeRTOS-tól teljesen független megszakítások.
\end{itemize}

A FreeRTOS által kezelt prioritások kritikus szakaszba lépéskor letiltásra kerülnek, így azok nem szakíthatják meg az atomi utasításként futtatandó kódrészletet. Viszont a megszakítások ezen csoportja használhatja a \emph{FromISR}-re végzõdõ FreeRTOS API függvényeket.

A FreeRTOS-tól független megszakítások kezelése teljes mértékben a fejlesztõ feladata. Az operációs rendszer nem tudja megakadályozni a futásukat, így a kritikus szakaszban is képesek futni. A kiemelkedõen idõkritikus kódrészleteket célszerû ezekben a megszakítási turinokban megvalósítani (például motorvezérlés). A FreeRTOS-tól független megszakítási rutinokban nem szabad API függvényeket használni!

%----------------------------------------------------------------------------
\subsection{Erõforrás-kezelés}
%----------------------------------------------------------------------------

Multitaszk rendszerek esetén fennáll a lehetõsége, hogy egy taszk kikerül a Futó állapotból még mielõtt befejezné egy erõforrással a mûveleteket. Ha az erõforrást egy másik taszk is használni akarja, akkor inkonzisztencia léphet fel. Tipikus megjelenései a problémának:
\begin{itemize}
\item Periféria elérése,
\item Egy közös adat olvasása, módosítása, majd visszaírása,[lábjegyzet-> magas szintû nyelv esetén (pl C) ez látszólag lehet egy utasítás, viszont a fordító által elõállított gépi kód több utasításból áll]
\item Változó nem atomi elérése (például több tagú struktúra értékeinek megváltoztatása),
\item Nem reentráns függvények, [lábjegyzet-> reentráns függvény]
\end{itemize}

Az adat inkonzisztencia elkerüléséhez hasnzálhatunk mutex-et. Amikor egy taszk megkapja egy erõforrás kezelésének jogát, akkor más taszk nem férhet hozzá, egészen addig, amig a birtokló taszk be nem fejezte az erõforrással a feladatát, és az erõforrás felszabadítását mutex-en keresztül nem jelezte.

%----------------------------------------------------------------------------
\subsubsection{Kritikus szakasz}
%----------------------------------------------------------------------------

[ToDo -> Itt átfogalmazni kicsit a dolgokat. Elég kusza a gondolatmenet.]

A közös erõforrások használatakor gyakran szükség van egy adott mûveletsor atomivá tételére, azaz arra, hogy a kijelölt mûveletek futását semmi ne szakíthassa meg, látszólag egy utasításként fussanak le.

A FreeRTOS támogatja a kritikus szakaszok használatát a \emph{taskENTER\_CRITICAL()} és \emph{taskEXIT\_CRITICAL()} makrók használatával.

A kritikus szakaszokat minden probléma nélkül egymásba lehet ágyazni, mivel a rendszerkernel nyílvántartja, hogy milyen mélyen van az alkalmazás a kritikus szakaszokban. A rendszer csak akkor hagyja el a kritikus szakaszt, ha a számláló nullára csökken, vagyis ha minden \emph{taskENTER\_CRITICAL()} híváshoz tartozik egy \emph{taskEXIT\_CRITICAL()} is.

A kritikus szakaszt a lehetõ leggyorsabban el kell hagyni, különben a beérkezõ megszakítások válaszideje nagy mértékben megnõhet.

%----------------------------------------------------------------------------
\subsubsection{Ütemezõ felfüggesztése}
%----------------------------------------------------------------------------

A kritikus szakasz megvalósításának egy kevésbé drasztikus módja az ütemezõ letiltása. Ekkor a kódrészlet védett a más taszkok általi preemtálástól, viszont a megszakítások nem kerülnek letiltásra. Hátránya, hogy az ütemezõ elindítása hosszabb idõt vehet igénybe.

%----------------------------------------------------------------------------
\subsubsection{Gatekeeper taszk}
%----------------------------------------------------------------------------

A gatekeeper taszk alkalmazása a kölcsönös kizárás egy olyan megvalósítása, mely mûködésénél fogva védett a prioritás inverzió és a holtpont kialakulásával szemben.

A gatekeeper taszk egyedüli birtokosa egy erõforrásnak, így csak a taszk tudja közvetlenül elérni az erõforrást, a többi taszk közvetetten, a gatekeeper taszk szolgáltatásain keresztül tudja használni az erõforrást.

Amikor egy taszk használni akarja az erõforrást, akkor üzenetet küld a gatekeeper taszknak (általában sor használatával). Mivel egyedül a gatekeeper taszk jogosult elérni az erõforrást, és nincs szükség explicit mutex használatára.

A gatekeeper taszk Blokkolt állapotban vár, amíg nem érkezik üzenet a sorba. Az üzenet beérkezése után elvégzi a megfelelõ mûveleteket az erõforráson, majd ha kiürült a sor, akkor ismét Blokkolt állapotba kerül.

A megszakítások probléma nélkül tudják használni a gatekeeper taszkok szolgáltatásait, mivel a sorba való írás támogatott megszakítási rutinból is.

%----------------------------------------------------------------------------
\subsection{Memória-kezelés}
%----------------------------------------------------------------------------

Beágyazott alkalmazások fejlesztése során is szükség van dinamikus memóriafoglalásra. Az asztali alkalmazásoknál megszokott \emph{malloc()} és \emph{calloc()} függvények több szempontból sem felelnek meg mikrokontrolleres alkalmazásokban:
\begin{itemize}
\item Kisebb rendszerekben nem biztos, hogy elérhetõ,
\item Az implementációjuk sok helyet foglalhat,
\item Nem determinisztikus a lefutásuk; a végrehajtási idõ különbözhet különbözõ híváskor,
\item Memóriatöredezettség léphet fel.
\end{itemize}

Minden taszkhoz tartozik egy TCB (\emph{Task Control Block}) és egy stack. A TCB struktúra a következõ elemeket tartalmazza (a teljesség igénye nélkül):

\begin{table}[h!]
\caption{A FreeRTOS TCB-jének fõbb változói.}
\label{tab:freertos_tcb}
\center
\begin{tabular}{|p{3.5cm}|p{8cm}|}
\hline
Változó & Jelentés \\
\hline
\hline
pxTopOfStack & Az stack utolsó elemére mutató pointer \\
\hline
xGenericListItem & A FreeRTOS a TCB ezen elemét helyezi az adott állapothoz tartozó listába (nem magát a \mbox{TCB-t}) \\
\hline
xEventListItem & A FreeRTOS a TCB ezen elemét helyezi az adott eseményhez tartozó listába (nem magát a \mbox{TCB-t}) \\
\hline
uxPriority & A taszk prioritása \\
\hline
pxStack & A stack kezdetére mutató pointer \\
\hline
pcTaskName & A taszk neve. Kizárólag debug célokra \\
\hline
pxEndOfStack & A stack végére mutató pointer a stack túlcsordulásának detektálására \\
\hline
uxBasePriority & Az utojára taszkhoz rendelt prioritás. Mutex használata esetén a prioritás öröklés során megnövelt prioritás visszaállítására \\
\hline
ulRunTimeCounter & A taszk \textbf{Fut} állapotban töltött idejét tárolja futási statisztika készítéséhez \\
\hline
\end{tabular}
\end{table}

Az egyes alkalmazások különböznek memória-allokációs igényükben és az erõírt idõzítési korlátokban, ezért nincs olyan memória-allokációs séma, amely minden alkalmazásban megállná a helyét. A FreeRTOS több allokációs algoritmust is a fejlesztõ rendelekezésére bocsát, amibõl az alkalmazásnak megfelelõ kiválasztásával lehet elérni a megfelelõ mûködést.

%----------------------------------------------------------------------------
\subsubsection{Heap\_1.c}
%----------------------------------------------------------------------------

Kisebb beágyazott alkalmazásoknál gyakran még az ütemezõ indulása elõtt létrehozunk minden taszkot és kommunikációs objektumot. Ilyenkor elég a memóriát lefoglalni az alkalmazás indulása elõtt, és a futás alatt minden memória lefoglalva marad. Ez azt is jelenti, hogy nem kell komplex algoritmusokat megvalósítani a determinisztikusság biztosítására és a Memóriatöredezettség ellkerülésére, hanem elég a kódméretet és az egyszerûséget szem elõtt tartani.

Ezt az implementációt tartalmazza a \emph{heap\_1.h}. A fájl a \emph{pvPortMalloc()} egyszerû megvalósítását tartalmazza, azonban a \emph{pvPortFree()} nincs implementálva. A \emph{heap\_1.c} nem fenyegeti a rendszer determinisztikusságát.

A \emph{pvPortMalloc()} függvény a FreeRTOS heap-jét ossza fel kisebb területekre, majd ezeket rendeli hozzá az egyes taszkokhoz. A heap teljes méretét a \emph{configTOTAL\_HEAP\_SIZE} konfigurációs érték határozza meg a \emph{FreeRTOSConfig.h} fájlban. Nagy méretû tömböt definiálva már a memórifoglalás elõtt látszólag sok memóriát fog felhasználni az alkalmazás, mivel a FreeRTOS ezt induláskor lefoglalja.

\begin{figure}[h!]
\center
\resizebox{13cm}{!}{
\includegraphics{figures/FreeRTOS/04_heap1.png}}
\caption{A heap\_1.c implementációjának mûködése.}
\label{fig:04_heap1}
\end{figure}

%----------------------------------------------------------------------------
\subsubsection{Heap\_2.c}
%----------------------------------------------------------------------------

A \emph{heap\_2.c} szintén a \emph{configTOTAL\_HEAP\_SIZE} konfigurációs értéket használja, viszont a \emph{pvPortMalloc()} mellett már implementálva van a \emph{pvPortFree()} is. A memóriafoglalás során a legjobban illeszkedõ területbõl oszt ki a taszk számára memóriát.

A legjobban illeszkedõ (best fit) algoritmus biztosítja, hogy a memóriakérés a hozzá méretben legközelebb esõ, elgendõ nagyságú blokkból legyen kiszolgálva.

A megvalósítás nem egyesíti a szomszédos szabad területeket egy nagyobb egységes blokkba, így töredezettség léphet fel. Ez nem okoz gondot, ha a lefoglalt és felszabadított memória mérete nem változik.

A \emph{heap\_2.c} fájl használata javasolt, ha az alkalmazás ismételve létrehoz és töröl taszkokat, és a taszkokhoz tartozó stack mérete nem változik.

\begin{figure}[h!]
\center
\resizebox{13cm}{!}{
\includegraphics{figures/FreeRTOS/05_heap2.png}}
\caption{A heap\_2.c implementációjának mûködése.}
\label{fig:05_heap2}
\end{figure}

A \emph{heap\_2.c} mûködése nem determinisztikus, de hatékonyabb, mint a \emph{standard library} implementációi.

%----------------------------------------------------------------------------
\subsubsection{Heap\_3.c}
%----------------------------------------------------------------------------

A \emph{heap\_3.c} a \emph{standard library} függvényeit használja, de a függvények alatt felfüggeszti az ütemezõ mûködését, ezzel elérve, hogy a memória-kezelés thread-safe legyen.

A heap méretét nem befolyásolja a \emph{configTOTAL\_HEAP\_SIZE} érték, ehelyett a linker beállításai határozza meg.