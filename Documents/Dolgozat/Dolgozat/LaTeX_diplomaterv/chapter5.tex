%----------------------------------------------------------------------------
\chapter{Megvalósítás}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\section{STM32F4~Discovery}
%----------------------------------------------------------------------------

A STM32F4~Discovery kártyára való fejlesztés során az \emph{Atollic~TrueSTUDIO} fejlesztõkörnyezet ingyenes verzióját, illetve az \emph{STM32CubeMX} konfiguráló alkalmazást használtam. Mindkét operációs rendszernél kikapcsoltam az optimalizációt.

%----------------------------------------------------------------------------
\subsection{FreeRTOS}
\label{sec:freertosImplementation}
%----------------------------------------------------------------------------

Az STM honlapjáról letölthetõ STM32CubeMX alkalmazás támogatja a FreeRTOS és FatFS\footnote{Fat fájlrendszer használatához elérhetõ könyvtár, mely az SD kártya használatához szükséges.} használatát, így a megfelelõ perifériák beállítása és a szükséges modulok kiválasztása után mûködõ példaprogram generálható.

A generált kód áttekintése közben észrevettem, hogy az operációs rendszer függvényeinek nevei nem egyeznek meg \asecref{freertos}ben megismert függvények neveivel. Ennek oka, hogy a CubeMX a FreeRTOS függvényeit a CMSIS-RTOS API-val elfedi, és egy egyszerûsített felületet biztosít a fejlesztõ számára. Ez az egyszerûsített felület például a szemaforok használatánál figyelhetõ meg, ahol nincs külön metódus a megszakításból történõ használatra, hanem az API vizsgálja meg, hogy megszakítás-kezelõ rutinból történt-e a hívás, és ennek megfelelõen végzi el a további mûveleteket. Mivel az összehasonlítás során a fejlesztési folyamat nehézségei is szempontként szerepelnek, ezért éltem az API használatával.

Mielõtt \asecref{softwareDesign}ben ismertetett taszkokat implementáltam volna, a rendszer megismerésével foglalkoztam. Valahogy el kellett érnem, hogy az éppen futó taszkhoz azonosítót rendeljek, amit valahogy az ID lábakon jelezni is tudok. Ehhez kihasználtam azt, hogy minden taszk rendelkezik névvel, így megfontolt elnevezéssel minden taszkhoz rendelhetõ 4~bites azonosító, amit a TCB-bõl is egyszerûen kiolvashatok.

Az ASCII karakterek táblázatát megvizsgálva látható, hogy az ``A'' karaktertõl kezdõdõen a betûk alsó bitjei használhatóak az ID lábak értékének meghatározására. Az azonosítók kiosztásánál úgy döntöttem, hogy a $0\textrm{x}0$ érték tartozzon az ütemezõhöz, a $0\textrm{x}1$ az Idle taszkhoz, és a nagyobb értékek tartozzanak a mérésben részt vevõ taszkokhoz. Így az egyes taszkok nevei ``B''-tõl ``O''-ig terjedhetnek.

A következõ lépés volt a rendszer ütemezési mechanizmusának tanulmányozása. Meg kellett keresnem azokat a részeket, amelyek minden ütemezésnél lefutnak, és az ütemezés indulásakor a $0\textrm{x}0$ azonosítót kellett kitennem az ID lábakra, míg az ütemezés végén a kiválasztott taszk azonosítóját. A FreeRTOS két esetben futtatja le az ütemezõt:
\begin{itemize}
  \item SysTick esemény bekövetkezésekor,
  \item portYIELD() függvény hívásakor.
\end{itemize}

Ezért a \emph{portYIELD()} függvény elején, illetve a \emph{SysTick} megszakítás-kezelõ rutin elején \alstref{schedulerID}ában látható assembly utasításokkal helyeztem ki az ütemezõ azonosítóját. A \emph{portYIELD()} függvény minden esetben kontextus-váltást kér a \emph{PendSV} megszakításon keresztül, ellenben a \emph{SysTick} kezelõ csak szükséges esetben. Emiatt a \emph{SysTick} rutint módosítanom kellett, és amennyiben nem szükséges kontextus-váltás, úgy az aktuális taszk azonosítóját helyezem az ID lábakra.

Kontextus-váltás esetén a \emph{PendSV} megszakítás-kezelõ végzi el az éppen futó taszk állapotának elmentését és a soron következõ taszk legutolsó állapotának betöltését. A taszkváltás elvégzése után, a megszakításból való visszatérés elõtt a betöltött taszk azonosítóját helyezem az ID lábakra \alstref{freertosTaskID}ában látható módon.

A taszk nevének eléréséhez a FreeRTOS-ban használt TCB struktúra változót kellett leszámolnom. A taszk neve elõtti változók összesen $52$~byte hosszúak, ebbõl adódik \alstref{freertosTaskID}a hatodik sorában található konstans ofszet.

\begin{lstlisting}[caption={Ütemezõ azonosítójának kihelyezése a lábakra.}\label{lst:schedulerID},numbers={left}]
"   push {r0, r1, r2}             \n"
"   movw r0, #0x0C14              \n" /* GPIOD cimenek betoltese */
"   movt r0, #0x4002              \n"
"   ldr r2,[r0, #0]               \n"
"   and r2, r2, #0xFFFFFF0F       \n"
"   str r2, [r0, #0]              \n" /* Null ertekek kiirasa a labakra */
"   pop {r0, r1, r2}              \n"		
\end{lstlisting}

\begin{lstlisting}[caption={Aktuális taszk azonosítójának kihelyezése a lábakra (FreeRTOS).}\label{lst:freertosTaskID},numbers={left}]
"   push {r0, r1, r2}             \n"
"   ldr	r0, pxCurrentTCBConst     \n" /* Aktualis TCB betoltese. */
"   ldr	r2, [r0]                  \n"
"   movw r0, #0x0C14              \n" /* GPIOD cimenek betoltese */
"   movt r0, #0x4002              \n"
"   ldr r1, [r2, #52]             \n" /* Taszk ID kiolvasas */
"   lsl r1, r1, #4                \n" /* ID helyre mozgatasa */
"   and r1, r1, #0x000000F0       \n" /* Maszkolasok */
"   ldr r2, [r0, #0]              \n"
"   and r2, r2, #0xFFFFFF0F       \n"
"   orr r2, r2, r1                \n"
"   str r2, [r0, #0]              \n" /* Ertek kihelyezese a labakra */
"   pop {r0, r1, r2}              \n"
\end{lstlisting}

A módosítások tesztelése után \asecref{softwareDesign}ben bemutatott taszkok implementálása következett.

Minden mérésnek új projektet létrehozni nem lett volna célszerû, ezért makrók segítségével lehet kiválasztani az aktuális mérést. A konfigurációs fájl részlete látható \alstref{measurementDefines}án\footnote{A \emph{BLINKING\_LED} a fejlesztés során segítette a hibás mûködés észrevételét.}.

A következõ lépés az ipari alkalmazás implementációja volt. Minden taszk mûködésének ismertetése hosszadalmas -- és egyben felesleges is -- volna, ezért csak a fejlesztés szempontjából érdekes részleteket emelem ki.

A távoli felügyeletet soros kommunikáció segítségével valósítottam meg, amihez célszerû volt valamilyen egyszerû protokollt meghatároznom. Mivel több szenzor adatát is továbbítanom kellett, és a küldött információk sorrendje változhatott, ezért a protokollnak tartalmaznia kellett az adatok forrását. A legnagyobb továbbítandó érték $4$~byte hosszú volt, ezért az üzenet formátumát az alábbi módon határoztam meg:
\begin{itemize}
  \item Az adat forrása (szenzor neve) nyolc karakteren,
  \item Elválasztó karakter (:),
  \item Adat ($4$~byte),
  \item Lezáró karakter (sortörés).
\end{itemize}

\begin{lstlisting}[language=C,numbers={left},keywordstyle={\color{blue}},stringstyle={\color{red}},commentstyle={\color{olive}},morecomment={[l][\color{red}]{\#}},tabsize=2, caption={Mérés kiválasztását megvalósító makrók.} \label{lst:measurementDefines}]
/**
 * Mérési folyamat:
 *  MEAS_LATENCY:                   késleltetés mérés
 * 	MEAS_TASK_SWITCHING_TIME:       taszkváltási idõ mérés
 * 	MEAS_PREEMPTION_TIME:           preemtálási idõ mérés
 * 	MEAS_INTERRUPT_LATENCY_TIME:    megszakítás-késleltetési idõ mérés
 * 	MEAS_SEMAPHORE_SHUFFLING_TIME:  szemafor-váltási idõ mérés
 * 	MEAS_DEADLOCK_BREAKING_TIME:    deadlock-feloldási idõ mérés
 * 	MEAS_DATAGRAM_THROUGHPUT_TIME:  datagram-átviteli idõ mérés
 */
/**
 * Terhelés engedélyezése:
 *  MEAS_W_LOAD
 */
#define MEAS_LATENCY
//#define BLINKING_LED
//#define MEAS_W_LOAD
\end{lstlisting}

A kommunikáció során elõfordul, hogy a mikrokontroller számára küldött karakter nem kerül idõben fogadásra, és a periféria tárolója túlcsordul. Ekkor a periféria kezelése után az alkalmazás jelez a távoli vezérlõnek, hogy küldje újra az utolsó parancsot.

Az SD kártyára való naplózás során két probléma merült fel, melynek megoldása hosszabb idõt vett igénybe. Egyrészt amikor a naplófájl mérete elérte a kártya formázása során megadott szektorméretet, akkor az írás nem folytatódott. Erre hosszas kutatás után sem találtam elfogadható megoldást, viszont a fájl módosítását végzõ függvények kritikusz szakaszba ágyazásával a probléma megoldódott\footnote{Mivel a fájl kezelése viszonylag hosszú ideig tart, ezért ez a megoldás egy valós alkalmazásban nem felelne meg!}. A másik probléma akkor jelentkezett, ha mûködés közben eltávolítottam a memória kártyát, majd újból visszahelyeztem a foglalatba. A visszahelyezés után a kártyára való írás nem történt meg, a kezelõ függvények hibával tértek vissza. A \emph{FatFS} fügvényeinek tanulmányozásával azt vettem észre, hogy tagváltozóban tárolja, hogy az adott eszköz inicializálása megtörtént-e. Az inicilaizálást tároló változót csak az eszközt kezelõ \emph{driver} beállításakor törli, így a kártya inicializálása a többszöri behelyezés esetén nem valósul meg. Az alkalmazásban a kártya lecsatolásakor törlöm a változó értékét.

A BLE112 Bluetooth modul kezeléséhez szükséges függvények könyvtárát a gyártó a fejlesztõk számára regisztráció után elérhetõvé teszi. A fejlesztõnek csak az adatok küldését és fogadását megvalósító függvényeket kell implementálnia. A fogadó függvény a bejövõ adatot feldolgozza, majd meghívja az üzenethez tartozó függvényt, ahol a szükséges feladatokat elvégezhetjük.

A soros kommunikáció és a naplózás során \emph{gatekeeper} taszkokkal valósítottam meg az erõforrások kezelését.

Az egyes taszkok mûködése \aappref{flowCharts}ben található.

%----------------------------------------------------------------------------
\subsection{\textmugreek C/OS--III}
%----------------------------------------------------------------------------

A \textmugreek C/OS--III ütemezõje szintén a \emph{SysTick} eseményt használja a periodikus ütemezés megvalósítására, viszont a mechanizmus különbözik a FreeRTOS esetében megismerttõl.

A Idle taszk mellet az operációs rendszer inicializálásakor létrejön \emph{Tick} taszk is, ami periodikusan várakozik a beépített szemaforára. \emph{SysTick} megszakítás érkezésekor a megszakítás-kezelõ rutin jelez a Tick taszknak a szemaforon keresztül, majd a \emph{Pend} függvényhívás következtében az ütemezõ lefut. Mivel a \emph{Tick} taszk magas prioritással rendelkezik, ezért a késleltetés kicsi. A Tick taszk elvégzi a számlálók kezelését, majd várakozik a következõ jelzésre, ezzel újabb ütemezést elindítva.

A taszkok ütemezésést az \emph{OSSched()} függvény végzi, amely szükség esetén a \emph{PendSV} megszakítások keresztül kér kontextus váltást.

A \textmugreek C/OS--III esetében az ütemezõ azonosítóját az \emph{OSSched()} függvény elején, illetve a \emph{SysTick} esemény bekövetkezésekor kellett kitennem az ID lábakra (a FreeRTOS esetében megismert utasítások segítségével -- \lstref{schedulerID}a).

Az \emph{OSSched()} lefutása során két lehetõség áll fenn:
\begin{itemize}
  \item Nem szükséges kontextusváltást kezdeményezni. Ebben az esetben az \emph{OSSched()} függvény visszatérése elõtt történik meg az aktuális taszk azonosítójának kitétele az ID lábakra.
  \item Kontextusváltás következik be. Ekkor a \emph{PendSV} megszakítás befejezõdése elõtt kerül az azonosító kihelyezésre.
\end{itemize}

A \textmugreek C/OS--III TCB struktúrája különbözik a FreeRTOS-nál használt TCB struktúrájától. Egyrészt a TCB nem tartalmazza a nevet, csak arra mutató pointert, másrészt a TCB kezdetétõl számított ofszet is különbözik. Az ofszet értéke $32$~byte, mely \alstref{ucosTaskID}ában az ötödik sorban látható. A kinyert memóriacímrõl még be kell olvasni az azonosítót, ami a kilencedik sorban történik.

A \textmugreek C/OS--III a szemaforok és sorok mellett támogatja a közvetlenül a taszkoknak küldött jelzések és üzenetek használatát, mely hatékonyabb futás eredményez. Mivel a két rendszer összehasonlítása volt a cél, ezért úgy döntöttem, hogy azonos implementációt használok, és nem használom a beépített objektumokat.

Az datagram-átviteli idõ taszkjainak implementációja során felmerült a probléma, hogy a \textmugreek C/OS--III az üzenetre mutató pointereket használja a továbbítás során. A mérés leírásában hangsúlyozva szerepelt, hogy az átvitel ne pointer használatával történjen, ezért a mérés során a sorba az adat címe helyett magát az adatot helyeztem, és a fogadó taszk esetében is figyeltem, hogy helyesen olvassam ki az üzenet tartalmát\footnote{Mivel az adattovábbítás során $32$~bites adatot használtam, és az architektúra által használt pointerek is $32$~bitesek, ezért a megvalósítás nem okozott problémát. Összetett struktúra átvitele esetén bonyolultabb lett volna a helyzet.}.

A további taszkok implementációja úgy történik, mint ahogy a FreeRTOS esetében láthattuk.

\begin{lstlisting}[caption={Aktuális taszk azonosítójának kihelyezése a lábakra (\textmugreek C/OS--III).}\label{lst:ucosTaskID},numbers={left}]
"   push {r0, r1, r2}               \n"
"   movw r1, #:lower16:OSTCBCurPtr  \n"
"   movt r1, #:upper16:OSTCBCurPtr  \n"
"   ldr r2, [r1]                    \n"
"   ldr r0, [r2, #32]               \n" /* NamePtr betoltese */
"   mov r2, r0                      \n" /* Regiszter masolasa */
"   movw r0, #0x0C14                \n" /* GPIOD cimenek betoltese */
"   movt r0, #0x4002                \n"
"   ldr r1, [r2]                    \n" /* Taszk ID kiolvasas */
"   lsl r1, r1, #4                  \n" /* ID helyre mozgatasa */
"   and r1, r1, #0x000000F0         \n" /* Maszkolasok */
"   ldr r2, [r0, #0                 \n"
"   and r2, r2, #0xFFFFFF0F         \n"
"   orr r2, r2, r1                  \n"
"   str r2, [r0, #0]                \n" /* Ertek kihelyezese a labakra */
"   pop {r0, r1, r2}                \n"
\end{lstlisting}

%----------------------------------------------------------------------------
\subsection{Vezérlõ szoftver}
%----------------------------------------------------------------------------

A távoli vezérlést megvalósító szoftvert Qt fejlesztõkörnyezet használatával valósítottam meg.

A vezérlõ és az eszköz között a kommunikációt UART\footnote{A soros kommunikáció beállításához a példaprogramok között megtalálható \emph{Terminal} alkalmazást vettem alapul.} valósítja meg a \emph{Base Board}-on elérhetõ kivezetésen keresztül. A csatlakozáskor a vezérlõ jelzi az eszköz számára, amire az eszköz a LED-ek és kapcsolók aktuális állapotával válaszol. A kapott értékeknek megfelelõen az szoftver frissíti a felhasználói felületet.

A felületen a helyi és távoli hõmréséklet mellett a potméter állása grafikusan is megjelenítésre kerül, míg a környezeti hõmérséklet és a fényerõsség számértéke olvasható le a felületrõl. Jobb oldalon a kapcsolók és LED-ek jelenlegi állapotára utaló indikátorok láthatóak. A LED-ek értéke változtatható.

Az eszköztõl érkezõ adatok a szenzorokból kinyert nyers adatok, melyeket a vezérlõ szoftver dolgoz fel. A Sensortag által mért értékeket az adott szenzor adatlapjában meghatározott számolás alapján számoltam, míg a helyi hõmérséklet esetében a hõmérõ adatlapjában található hõmérséklet--feszültség karakterisztika alapján végeztem közelítõ számítást. Minden érték esetén átlagolt adat kerül megjelenítésre.

A grafikus felület \aappref{gui} \figref{remoteControl}áján látható.

%----------------------------------------------------------------------------
\section{Raspberry~Pi~3}
%----------------------------------------------------------------------------

A Raspberry~Pi~3-on használt rendszereknél a Rhealstone értékek mérése nem megvalósítható\footnote{A Windows~10~IoT~Code forráskódja nem elérhetõ, és a Raspbian rendszer esetében is kernelmódosításokat kéne eszközölni.}, és a háttérben futó több tíz -- esetenként több száz -- egyéb folyamat mellett nem is lenne célszerû. Ezért a két rendszer esetén a késleltetés és a legrosszabb válaszidõ kerül meghatározásra, illetve szubjetív szempontok alapján értékelem majd õket.

Mintkét rendszernél két alkalmazás került implementációra:
\begin{itemize}
  \item A szimulált ipari alkalmazás,
  \item Grafikus felület nélküli alkalmazás, mely a bemenetre érkezõ jelet a kimenetre másolja.
\end{itemize}

Az ipari alkalmazás esetén az adatok az eszközön kerülnek megjelenítésre.

%----------------------------------------------------------------------------
\subsection{Windows 10 IoT Core}
%----------------------------------------------------------------------------

A Windows~10~IoT~Core rendszer telepítése a \emph{Windows 10 IoT Core Dashboard} szoftver használatával történik. A szoftver felületén ki kell választanunk a használt fejlesztõeszközt (esetünkben Raspberry~Pi~2~\&~3), a telepíteni kívánt rendszert és a használt SD kártyát. Ezen felül megadhatjuk még az eszköz nevét és az adminisztrátori jelszót, illetve beállítható, hogy mely ismert WiFi hálózat beállításait szeretnénk használni az eszközön. A felhasználói feltételek elfogadását követõen a szoftver letölti az operációs rendszert és telepíti az SD kártyára.

A rendszer indulása után a Raspberry~Pi -- amennyiben kapcsolódik a hálózatra -- megjelenik a megtalált eszközök listájában. Az eszköz címét böngészõbe beírva az eszköz adminisztációs felületére jutunk, ahol többek között kezelhetjük a futó folyamatokat és monitorozhatjuk a rendszer terhelését is. Miután a böngészõn keresztül bekapcsoljuk a \emph{Remote Desktop} szolgáltatást, a \emph{Windows IoT Remote Client} alkalmazással távoli asztalként is használhatjuk a rendszert.

A Windows 10 IoT Core lehetõvé teszi \emph{headed} és \emph{headless} alkalmazások fejlesztését.
\begin{description}
  \item[Headed:] Rendelkezik grafikus felülettel. Egyszerre csak egy headed alkalmazás futhat.
  \item[Headless:] Nem rendelkezik grafikus felülettel. A háttérben egyszerre akár több headless alkalmazás is futhat.
\end{description}

A fejlesztés során \emph{Visual Studio 2017}-et használtam. Az új projekt létrehozásánál az \emph{Windows Universal} csoporton belül az üres sablonból indultam ki. A fejlesztõkörnyezet kezelõfelülete gyors fejlesztést tesz lehetõvé, így az ipari alkalmazás felhasználói felületének összeállítása nem okozott gondot\footnote{Raspberry Pi-n nem jelenítettem meg az értékeket külön grafikus elem használatával.}.

A háttérben zajló folyamatok implementációja során sem ütköztem komolyabb problémába, a legtöbb periféria beépített osztályok segítségével könnyen kezelhetõ volt. Viszont a Bluetooth használata nehézséget okozott. Alapos kutatás után arra jutottam, hogy a Windows 10 UWP Bluetooth API még aktív fejlesztés alatt áll, és amennyiben a kommunikáció létrehozása sikerülne, valószínûleg a továbbiakban újabb problémák merülnének fel. Ezért altenatív megoldást kerestem, és mivel a Raspberry Pi rendelkezik UART interfésszel is, ezért a BLE112 modul használata mellett döntöttem.

A Bluegiga egyik mérnökének GitHub oldalán elérhetõ a Bluetooth modulhoz könyvtár, mely az MIT licenc feltételei mellett használható. \Asecref{freertosImplementation}ben ismeretett metódusok megvalósítása után a kommunikáció az elvárt módon mûködött.

Az alkalmazás felülete \aappref{gui} \figref{windows10Gui}áján látható.

A headless alkalmazás pár sorban megvalósítható volt. Feliratkoztam a kijelölt GPIO láb változását jelzõ eseményre, és az eseményhez rendelt függvényben a kimeneti lábra másoltam a bemenet értékét.

%----------------------------------------------------------------------------
\subsection{Raspbian}
%----------------------------------------------------------------------------

A linux disztibúció telepítéséhez a rendszer képfájlját le kellett tölteni a Raspberry Pi hivatalos weboldaláról, majd külön szoftver segítségével kellett a fájlokat az SD kártyára másolni.

A fejlesztés megoldható lett volna asztali számítógépen, viszont a Raspbian lehetõségei ezt nem tették szükségessé. A rendszer csomagkezelõjének segítségével feltelepítettem a Qt fejlesztõkörnyezetet, és magán a Raspberry Pi-n végeztem a fejlesztést.

Mivel a Qt nem rendelkezik kiemelt támogatással a Raspberry Pi-vel kapcsolatban, ezért elõször az egyes perifériákat bírtam mûködésre.

Linux rendszerek esetén a legtöbb periféria állományként jelenik meg a fájlrendszeren belül\cite{OpreLin}. Ez Raspbian esetén is igaz maradt, és a GPIO lábakat a \verb;/sys/class/gpio/; elérési útvonalon érhetjük el. Itt található \verb;export; fájlba a használni kívánt láb számát beírva megjelenik a láb kezelését lehetõvé tevõ fájlokat tartalmazó mappa. Például az
\begin{lstlisting}
echo 4 > /sys/class/gpio/export
\end{lstlisting}
utasítás hatására létrejön a \verb;/sys/class/gpio/gpio4; mappa, amelyen belül az alábbi fájlok segítségével lehet a GPIO lábat kezelni:
\begin{description}
  \item[direction:] Meghatározza, hogy a lábat kimenetként vagy bemenetként használjuk. Lehetséges értékei: in, out.
  \item[value:] A láb jelenlegi értékét olvashatjuk ki a fájlon keresztül. Kimenet esetén a fájlba való írással változtathatjuk meg a láb állapotát. Lehetséges értékei: 0, 1.
  \item[edge:] A bemeneti láb változásakor a \verb;value; fájlból kiolvasott érték megfelel a lábon megfigyelhetõ jelszintnek, viszont a fájl metadatai nem változnak (mint például az utolsó módosítás dátuma). A \verb;edge; fájl tartalmának megváltoztatásával elérhetõ, hogy az adott változás esetén fájlleírón keresztül detektálható legyen a változás. Lehetséges értékei: none, rising, falling, both.
\end{description}

A GPIO lábak kezeléséhez létrehoztam egy osztályt, ami négy tagfüggvényt tartalmaz.

\begin{description}
  \item[Init(GPIOPin,GPIODirection):] A paraméterként átadott lábat konfigurálja fel a szintén paraméterként megadott irányba.
  \item[Read():] Visszatér a láb aktuális értékével.
  \item[Write(GPIOState):] A láb értékét a paraméterként kapott értékre módosítja.
  \item[WatchEdge(Enable):] Engedélyezi a lábon bekövetkezõ változás detektálását.
\end{description}

Az implementáció során az ismertetett állományok segítségével inicializálom a lábat. Olvasás és írás esetén a lábhoz tartozó \verb;value; fájl tartalmát olvasom ki, illetve módosítom. Az éldetektálás engedélyezésekor az \verb;edge; fájl írásával mind a felfutó, mind a lefutó él változásának jelzését engedélyezem, és \emph{QFileSystemWatcher} objektum használatával figyelem a \verb;value; fájl változását. Amennyiben a fájlon változás történik, úgy összehasonlítom a láb aktuális értékét a legutóbb kiolvasott értékkel (valóban történt-e változás), és az osztály \emph{EdgeDetected(value)} signal-ján keresztül jelzést küldök.

Tekintettel arra, hogy Windows 10 IoT Core rendszer esetén nem a Raspberry Pi beépített Bluetooth eszközét használtam, úgy döntöttem, hogy Raspbian esetén is a BLE112 Bluetooth modul segítségével valósítom meg a vezeték nélküli kommunikációt. Ehhez szükség volt az utasítások magas szintû kezelését lehetõvé tevõ objektumra, amely UART-on keresztül kezeli a modult.

A soros kommunikáció használatát a Qt támogatja, és mivel az asztali alkalmazásnál is alkalmaztam, így a beállítása nem okozott gondot. Viszont a Bluetooth modulhoz nem találtam \Cpp{ } fejlesztéshez használható könyvtárakat, ezért végül a \Csh{ }programozás során használt könyvtár alapján implementáltam a szükséges függvényeket.

Az I$^\textrm{2}$C kommunikáció megvalósításához a \emph{wiringPi} függvénykönyvtárat használtam.

Az perifériákat egyesével tesztelve megbizonyosodtam a mûködésükrõl, majd a tesztelés során készített programok felhasználásával összeállítottam a teljes alkalmazást. Az alkalmazás felületérõl \aappref{gui} \figref{raspbianGui}áján láthatunk képet.

A grafikus felület nélküli alkalmazás a Raspbian esetében is néhány sorral megvalósítható volt. 